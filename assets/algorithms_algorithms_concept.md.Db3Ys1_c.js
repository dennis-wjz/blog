import{_ as t,c as e,o as l,a4 as n}from"./chunks/framework.BxgpPnKs.js";const p=JSON.parse('{"title":"算法概念","description":"","frontmatter":{"title":"算法概念","customTag":"algorithms>算法","date":"2024.06.20","editLink":true},"headers":[],"relativePath":"algorithms/algorithms/concept.md","filePath":"algorithms/algorithms/concept.md","lastUpdated":1736264532000}'),a={name:"algorithms/algorithms/concept.md"},d=n('<h1 id="算法基础概念" tabindex="-1">算法基础概念 <a class="header-anchor" href="#算法基础概念" aria-label="Permalink to &quot;算法基础概念&quot;">​</a></h1><p>算法是一组指令或操作步骤，用于在有限时间内解决特定问题。其特点包括问题明确、可行性强，能在有限步骤、时间和内存空间内完成，并且在相同条件下输出始终相同</p><h2 id="算法复杂度" tabindex="-1">算法复杂度 <a class="header-anchor" href="#算法复杂度" aria-label="Permalink to &quot;算法复杂度&quot;">​</a></h2><p>在算法中，我们主要看两个层面的目标：</p><ol><li>**找到问题解法：**正确解法</li><li>**寻找最优解法：**最优解最高效</li></ol><p>衡量算法优劣的指标，主要两个维度：</p><ul><li>**时间效率：**运行时间长短</li><li>**空间效率：**占用内存</li></ul><p>小tips：在深入学习数据结构与算法之前，先对复杂度分析建立初步的了解，以便能够完成简单算法的复杂度分析</p><p>在学习复杂度之前，我们先来了解两个概念，迭代与递归</p><ul><li><strong>迭代</strong>：重复执行直到条件不满足，常见的有for、while循环</li><li><strong>递归</strong>：算法策略，通过调用自身，主要可以拆分成两个阶段： <ol><li>不断调用自身，直到终止条件</li><li>触发终止条件后，逐层返回结果</li></ol></li></ul><table><thead><tr><th style="text-align:center;"></th><th style="text-align:center;">迭代</th><th style="text-align:center;">递归</th></tr></thead><tbody><tr><td style="text-align:center;">实现方式</td><td style="text-align:center;">循环结构</td><td style="text-align:center;">函数调用自身</td></tr><tr><td style="text-align:center;">时间效率</td><td style="text-align:center;">效率通常较高，无函数调用开销</td><td style="text-align:center;">每次函数调用都会产生开销</td></tr><tr><td style="text-align:center;">内存使用</td><td style="text-align:center;">通常使用固定大小的内存空间</td><td style="text-align:center;">累积函数调用可能使用大量的栈帧空间</td></tr><tr><td style="text-align:center;">适用问题</td><td style="text-align:center;">适用于简单循环任务，代码直观、可读性好</td><td style="text-align:center;">适用于子问题分解，如树、图、分治、回溯等，代码结构简洁、清晰</td></tr></tbody></table><h3 id="时间复杂度" tabindex="-1">时间复杂度 <a class="header-anchor" href="#时间复杂度" aria-label="Permalink to &quot;时间复杂度&quot;">​</a></h3><p>时间复杂度描述的是算法的运行时间，常见的类型有：</p><table><thead><tr><th style="text-align:center;">时间复杂度</th><th style="text-align:center;">具体描述</th><th style="text-align:center;">典型算法</th></tr></thead><tbody><tr><td style="text-align:center;">O(1)</td><td style="text-align:center;">常数时间，执行时间不随输入大小变化</td><td style="text-align:center;">直接访问数组元素</td></tr><tr><td style="text-align:center;">O(log n)</td><td style="text-align:center;">对数时间，执行时间随输入大小呈对数增长</td><td style="text-align:center;">二分查找</td></tr><tr><td style="text-align:center;">O(n)</td><td style="text-align:center;">线性时间，执行时间与输入大小成正比</td><td style="text-align:center;">线性搜索</td></tr><tr><td style="text-align:center;">O(n log n)</td><td style="text-align:center;">线性对数时间，执行时间随输入大小呈线性对数增长</td><td style="text-align:center;">快速排序、归并排序</td></tr><tr><td style="text-align:center;">O(n^2)</td><td style="text-align:center;">二次时间，执行时间与输入大小的平方成正比</td><td style="text-align:center;">冒泡排序、选择排序、插入排序</td></tr><tr><td style="text-align:center;">O(n^3)</td><td style="text-align:center;">立方时间，执行时间与输入大小的立方成正比</td><td style="text-align:center;">简单的矩阵乘法</td></tr><tr><td style="text-align:center;">O(2^n)</td><td style="text-align:center;">指数时间，执行时间以指数方式增加</td><td style="text-align:center;">某些递归问题解决方案</td></tr><tr><td style="text-align:center;">O(n!)</td><td style="text-align:center;">阶乘时间，执行时间随输入大小的阶乘增加</td><td style="text-align:center;">旅行商问题的暴力解法</td></tr></tbody></table><p>常见类型</p><p><code>O(1)</code> &lt; <code>O(log n)</code> &lt; <code>O(n)</code> &lt; <code>O(n log n)</code> &lt; <code>O(n^2)</code> &lt; <code>O(2^n)</code> &lt; <code>O(n!)</code></p><p>常数阶 &lt; 对数阶 &lt; 线性阶 &lt; 线性对数阶 &lt; 平方阶 &lt; 指数阶 &lt; 阶乘阶</p><h3 id="空间复杂度" tabindex="-1">空间复杂度 <a class="header-anchor" href="#空间复杂度" aria-label="Permalink to &quot;空间复杂度&quot;">​</a></h3>',18),r=[d];function i(c,s,o,g,h,x){return l(),e("div",null,r)}const _=t(a,[["render",i]]);export{p as __pageData,_ as default};
